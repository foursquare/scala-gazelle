package scala

import (
	"fmt"
	"log"
	"path/filepath"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"

	"github.com/emirpasic/gods/sets/treeset"

	"github.com/foursquare/scala-gazelle/jvm"
	"github.com/foursquare/scala-gazelle/parse"
)

type scalaLang struct {
	*ScalaConfigurer
	language.FinishableLanguage

	parser                 parse.Parser[ParseResult]
	currentExportedSymbols *treeset.Set
}

// NewLanguage is called by Gazelle to install this language extension in a binary.
func NewLanguage() language.Language {
	lang := scalaLang{
		parser:                 nil, // populated during ScalaConfigurer's CheckFlags
		currentExportedSymbols: nil,
	}

	lang.ScalaConfigurer = NewScalaConfigurer(&lang)

	return &lang
}

// Name returns the name of the language. This should be a prefix of the
// kinds of rules generated by the language, e.g., "go" for the Go extension
// since it generates "go_library" rules.
func (l *scalaLang) Name() string {
	return LANGUAGE_NAME
}

// Kinds returns a map of maps rule names (kinds) and information on how to
// match and merge attributes that may be found in rules of those kinds. All
// kinds of rules generated for this language may be found here.
//
// MatchAny is true if a rule of this kind may be matched with any rule
// of the same kind, regardless of attributes, if exactly one rule is
// present in a build file.
//
// NonEmptyAttrs is a set of attributes that, if present, disqualify a rule
// from being deleted after merge.
//
// MergeableAttrs is a set of attributes that should be merged before
// dependency resolution. See rule.Merge.
//
// ResolveAttrs is a set of attributes that should be merged after
// dependency resolution. See rule.Merge.
func (*scalaLang) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		SCALA_LIB_KIND: {
			MatchAny: true,
			NonEmptyAttrs: map[string]bool{
				"srcs": true,
			},
			MergeableAttrs: map[string]bool{
				"srcs": true,
			},
			ResolveAttrs: map[string]bool{
				"deps": true,
			},
		},
		SCALA_MACRO_KIND: {
			MatchAny: true,
			NonEmptyAttrs: map[string]bool{
				"srcs": true,
			},
			MergeableAttrs: map[string]bool{
				"srcs": true,
			},
			ResolveAttrs: map[string]bool{
				"deps": true,
			},
		},
		SCALA_JUNIT_TEST_KIND: {
			MatchAny: true,
			NonEmptyAttrs: map[string]bool{
				"srcs": true,
			},
			MergeableAttrs: map[string]bool{
				"srcs":     true,
				"suffixes": true,
			},
			ResolveAttrs: map[string]bool{
				"deps": true,
			},
		},
		SCALA_TEST_KIND: {
			MatchAny: true,
			NonEmptyAttrs: map[string]bool{
				"srcs": true,
			},
			MergeableAttrs: map[string]bool{
				"srcs": true,
			},
			ResolveAttrs: map[string]bool{
				"deps": true,
			},
		},
	}
}

// Loads returns .bzl files and symbols they define. Every rule generated by
// GenerateRules, now or in the past, should be loadable from one of these
// files.
func (l *scalaLang) Loads() []rule.LoadInfo {
	scalaLoadPath := fmt.Sprintf(
		"@%s//scala:scala.bzl",
		l.ScalaConfigurer.RulesScalaRepoName,
	)

	return []rule.LoadInfo{
		{
			Name: scalaLoadPath,
			Symbols: []string{
				SCALA_LIB_KIND,
			},
		},
		{
			Name: scalaLoadPath,
			Symbols: []string{
				SCALA_MACRO_KIND,
			},
		},
		{
			Name: scalaLoadPath,
			Symbols: []string{
				SCALA_JUNIT_TEST_KIND,
			},
		},
		{
			Name: scalaLoadPath,
			Symbols: []string{
				SCALA_TEST_KIND,
			},
		},
	}
}

// GenerateRules extracts build metadata from source files in a directory.
// GenerateRules is called in each directory where an update is requested
// in depth-first post-order.
//
// args contains the arguments for GenerateRules. This is passed as a
// struct to avoid breaking implementations in the future when new
// fields are added.
//
// A GenerateResult struct is returned. Optional fields may be added to this
// type in the future.
//
// Any non-fatal errors this function encounters should be logged using
// log.Print.
func (l *scalaLang) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	// TODO(jacob): We currently ignore directories without BUILD files, should we actually
	//		be recursing into sub-directories to find otherwise orphaned source files? This
	//		is what, e.g., the Python gazelle plugin does, which corresponds to how Bazel
	//		thinks about package boundaries.
	if args.File == nil || args.RegularFiles == nil || len(args.RegularFiles) == 0 {
		return language.GenerateResult{}
	}

	scalaConfig := ScalaConfigForArgs(args)

	ruleName := filepath.Base(args.Rel)
	ruleKind := SCALA_LIB_KIND
	var existingKind *string = nil
	for _, existingRule := range args.File.Rules {
		if existingRule.Name() == ruleName {
			kind := existingRule.Kind()
			existingKind = &kind
			if scalaConfig.IsScalaMacroKind(args.Config, kind) {
				ruleKind = SCALA_MACRO_KIND
			}
			break
		}
	}

	warnedAboutTestConflict := !scalaConfig.WarnTestRuleMismatch
	scalaSrcs := make([]string, 0, len(args.RegularFiles))
	allSrcs := make([]string, 0, len(args.RegularFiles))
	for _, filename := range args.RegularFiles {
		filepathExt := filepath.Ext(filename)

		if filepathExt == SCALA_EXT {
			allSrcs = append(allSrcs, filename)
			scalaSrcs = append(scalaSrcs, filename)

			if scalaConfig.IsScalaTestFile(filename) {
				if existingKind != nil && !scalaConfig.IsScalaTestKind(args.Config, *existingKind) {
					if !warnedAboutTestConflict {
						log.Printf(
							"WARN: Package '%s' contains a conflicting rule of kind '%s', "+
								"but appears to also contain test files. If you are adding a "+
								"new test file, please consider moving it to another directory "+
								"to avoid mixing library and test code, or manually update the "+
								"rule to the appropriate test kind so the tests will run. If "+
								"not, you may consider changing the file names to not match "+
								"against the configured test file suffixes (%v) or setting "+
								"'# gazelle:%s false' in its build file to make this warning "+
								"go away.",
							args.Rel,
							*existingKind,
							*scalaConfig.ScalaTestFileSuffixes,
							ScalaWarnTestRuleMismatch,
						)
						warnedAboutTestConflict = true
					}

				} else {
					ruleKind = scalaConfig.ScalaTestKind
				}
			}

		} else if filepathExt == JAVA_EXT {
			allSrcs = append(allSrcs, filename)
		}
	}

	if len(scalaSrcs) == 0 {
		return language.GenerateResult{}
	}

	deps := treeset.NewWithStringComparator()
	l.currentExportedSymbols = treeset.NewWithStringComparator()
	for _, filename := range scalaSrcs {
		absPath := filepath.Join(args.Dir, filename)
		parseResult, errs := l.parser.ParseFile(absPath)

		if errs != nil && len(errs) != 0 {
			var b strings.Builder
			fmt.Fprintf(
				&b,
				"ERROR: failed parsing scala file %s\n",
				absPath,
			)
			for _, err := range errs {
				fmt.Fprintf(&b, "%s\n", err)
			}
			log.Fatalf(b.String())
		}

		deps = deps.Union(parseResult.FullyQualifiedNames)
		deps = deps.Union(parseResult.Imports)

		// TODO(jacob): Have our parsers just spit out fully qualified names so we don't
		//		have to recreate them here.
		symbolsIter := parseResult.ExportedSymbols.Iterator()
		for symbolsIter.Next() {
			symbol := symbolsIter.Value().(string)
			l.currentExportedSymbols.Add(
				fmt.Sprintf("%s.%s", parseResult.Package, symbol),
			)
		}

		l.currentExportedSymbols.Add(parseResult.Package)
	}

	scalaRule := rule.NewRule(ruleKind, ruleName)
	scalaRule.SetAttr("srcs", allSrcs)
	scalaRule.SetAttr("visibility", DEFAULT_VISIBILITY)

	if ruleKind == SCALA_JUNIT_TEST_KIND {
		scalaRule.SetAttr("suffixes", *scalaConfig.ScalaTestFileSuffixes)
	}

	return language.GenerateResult{
		Gen:     []*rule.Rule{scalaRule},
		Imports: []interface{}{deps},
	}
}

// DoneGeneratingRules is called when all calls to GenerateRules have been
// completed.
// This allows for hooks to be called, for instance to release resources
// such as shutting down a background server.
// No further calls will be made to GenerateRules on this Language instance
// after this method has been called.
func (l *scalaLang) DoneGeneratingRules() {
	l.parser.WriteParsingCache()
}

// Imports returns a list of ImportSpecs that can be used to import
// rule r. This is used to populate RuleIndex.
//
// If nil is returned, the rule will not be indexed. If any non-nil slice is
// returned, including an empty slice, the rule will be indexed.
//
// NOTE(jacob): This function is what answers the question "What importable symbols does
//
//	this rule define?" Essentially it returns a list of potential imports -- for scala,
//	this is our parsed set of exported symbols.
func (l *scalaLang) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	ruleKind := r.Kind()
	// TODO(jacob): Ban deps on test rules?
	if !(ruleKind == SCALA_LIB_KIND ||
		ruleKind == SCALA_MACRO_KIND ||
		ruleKind == SCALA_JUNIT_TEST_KIND ||
		ruleKind == SCALA_TEST_KIND) || r.Attr("srcs") == nil {
		return nil
	}

	exportedSymbols := l.currentExportedSymbols
	l.currentExportedSymbols = nil
	if exportedSymbols == nil {
		log.Printf(
			"Package '%s' does not have exported symbols available, does it exist and "+
				"contain Scala source files?\n",
			f.Pkg,
		)
		return nil
	}

	importSpecs := make([]resolve.ImportSpec, 0, exportedSymbols.Size())
	symbolsIterator := exportedSymbols.Iterator()
	for symbolsIterator.Next() {
		symbol := symbolsIterator.Value().(string)
		importSpec := resolve.ImportSpec{
			Lang: LANGUAGE_NAME,
			Imp:  symbol,
		}
		importSpecs = append(importSpecs, importSpec)
	}

	return importSpecs
}

// Resolve translates imported libraries for a given rule into Bazel
// dependencies. Information about imported libraries is returned for each
// rule generated by language.GenerateRules in
// language.GenerateResult.Imports. Resolve generates a "deps" attribute (or
// the appropriate language-specific equivalent) for each import according to
// language-specific rules and heuristics.
func (l *scalaLang) Resolve(
	c *config.Config,
	ruleIndex *resolve.RuleIndex,
	rc *repo.RemoteCache,
	r *rule.Rule,
	imports interface{},
	from label.Label,
) {
	switch r.Kind() {
	case SCALA_LIB_KIND,
		SCALA_MACRO_KIND,
		SCALA_JUNIT_TEST_KIND,
		SCALA_TEST_KIND:

		usedSymbols := imports.(*treeset.Set)
		deps := jvm.ResolveJvmSymbols(
			c,
			ruleIndex,
			from,
			LANGUAGE_NAME,
			usedSymbols,
		)

		if deps.Empty() {
			r.DelAttr("deps")
		} else {
			r.SetAttr("deps", deps.Values())
		}

	default:
		return
	}
}

// CrossResolve attempts to resolve an import string to a rule for languages
// other than the implementing extension. lang is the langauge of the rule
// with the dependency.
//
// NOTE(jacob): For our purposes, this allows resolving dependencies in other languages
//
//	(e.g. Java) on Scala code or 3rdparty maven jars. The opposite direction (e.g.
//	Scala code depending on Java) is handled by the other languages' CrossResolves
//	(TODO: add CrossResolve support for the Java gazelle plugin).
//
//	CrossResolve functions are called via ruleIndex.FindRulesByImportWithConfig in our
//	jvm.ResolveJvmSymbols helper.
func (l *scalaLang) CrossResolve(
	c *config.Config,
	ruleIndex *resolve.RuleIndex,
	importSpec resolve.ImportSpec,
	lang string,
) []resolve.FindResult {
	if !l.ScalaConfigurer.CrossResolveLangs.Contains(lang) {
		return nil
	}

	// There are two language values that must match for us to successfully cross resolve:
	//
	//    1. The language passed to ruleIndex.FindRulesByImport must match the Resolver's
	//      language/Name().
	//    2. The language contained in the ImportSpec must match the language of an
	//      ImportSpec returned by the Resolver's Imports function.
	//
	// To avoid indexing symbols multiple times over (one for each language), we only
	// return JVM symbol ImportSpecs for Scala's language. Thus we have to rewrite the
	// ImportSpec's language here before doing its cross-resolve lookup.
	importSpec.Lang = LANGUAGE_NAME

	// NOTE(jacob): We don't do any symbol rewriting here, as CrossResolve is only called
	//    through ruleIndex.FindRulesByImportWithConfig via jvm.ResolveJvmSymbols which
	//    handles rewrites for us. This means we only want to look for exact matches here.
	//    Regrettably we are forced into using the deprecated ruleIndex.FindRulesByImport,
	//    as there is no way to opt ruleIndex.FindRulesByImportWithConfig out of checking
	//    CrossResolvers. If some resolvers are co-dependent on each other (e.g. Scala
	//    tries to cross-resolve Java and Java tries to cross-resolve Scala), we can end up
	//    infinitely recursing. ruleIndex.FindRulesByImport doesn't call CrossResolvers and
	//    thus doesn't run into this issue.
	return ruleIndex.FindRulesByImport(importSpec, LANGUAGE_NAME)
}

// language.Language interface methods we don't care about but must implement
func (*scalaLang) Fix(c *config.Config, f *rule.File) {}

// resolve.Resolver interface methods we don't care about but must implement
func (*scalaLang) Embeds(r *rule.Rule, from label.Label) []label.Label { return nil }
